"use strict";(self.webpackChunkcryptosim_pro_client=self.webpackChunkcryptosim_pro_client||[]).push([[476],{476:(t,e,r)=>{r.d(e,{coinGeckoService:()=>c});var o=r(722);const a="https://api.coingecko.com/api/v3";const c=new class{constructor(){this.cache=new Map,this.MARKET_TTL=3e4,this.OHLC_TTL=25e3,this.MAX_RETRIES=3,this.INITIAL_BACKOFF=500}async sleep(t){return new Promise(e=>setTimeout(e,t))}makeCacheKey(t,e){if(!e)return t;const r=Object.keys(e).sort().map(t=>"".concat(t,"=").concat(JSON.stringify(e[t])));return"".concat(t,"?").concat(r.join("&"))}async requestWithRetry(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(r&&a){const t=this.cache.get(r),e=Date.now();if(t){if(t.data&&t.expires>e)return t.data;if(t.promise)return t.promise}}const c=(async()=>{var c;let i=0,n=null;for(;i<this.MAX_RETRIES;)try{const c=await o.A.get(t,e);return r&&a&&this.cache.set(r,{data:c.data,expires:Date.now()+(a||0)}),c.data}catch(u){var s;n=u;const t=null===u||void 0===u||null===(s=u.response)||void 0===s?void 0:s.status;if(429===t)throw new Error("Rate limit exceeded (429) from CoinGecko. Back off and retry later.");var h,l;if(t&&t>=400&&t<500)throw new Error("CoinGecko API error: ".concat(t," ").concat(null!==(h=null===u||void 0===u||null===(l=u.response)||void 0===l?void 0:l.statusText)&&void 0!==h?h:""));i+=1;const e=this.INITIAL_BACKOFF*Math.pow(2,i-1);await this.sleep(e)}throw null!==(c=n)&&void 0!==c?c:new Error("Unknown network error")})();r&&a&&this.cache.set(r,{expires:Date.now()+(a||0),data:void 0,promise:c});try{const t=await c;return r&&a&&this.cache.set(r,{expires:Date.now()+(a||0),data:t}),t}catch(i){throw r&&this.cache.delete(r),i}}async getSupportedCoins(){try{const t="".concat(a,"/coins/list"),e=this.makeCacheKey(t);return await this.requestWithRetry(t,{},e,this.MARKET_TTL)}catch(t){throw console.error("Error fetching supported coins:",t),t}}async getMarketData(){try{const t="".concat(a,"/coins/markets"),e={vs_currency:"usd",order:"market_cap_desc",per_page:100,page:1,sparkline:!1},r=this.makeCacheKey(t,e);return await this.requestWithRetry(t,{params:e,timeout:1e4},r,this.MARKET_TTL)}catch(t){throw console.error("Error fetching market data:",t),t}}async getCoinMarketData(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"usd",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"1",o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"hourly";try{const c="".concat(a,"/coins/").concat(t,"/market_chart"),i={vs_currency:e,days:r,interval:o},n=this.makeCacheKey(c,i);return await this.requestWithRetry(c,{params:i,timeout:15e3},n,this.OHLC_TTL)}catch(c){throw console.error("Error fetching market data:",c),c}}async getCoinList(){try{const t="".concat(a,"/coins/list"),e=this.makeCacheKey(t);return await this.requestWithRetry(t,{},e,this.MARKET_TTL)}catch(t){throw console.error("Error fetching coin list:",t),t}}async getCoinPrice(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"usd";try{var r;const o="".concat(a,"/simple/price"),c={ids:t,vs_currencies:e},i=this.makeCacheKey(o,c),n=await this.requestWithRetry(o,{params:c,timeout:8e3},i,5e3);return null===n||void 0===n||null===(r=n[t])||void 0===r?void 0:r[e]}catch(o){throw console.error("Error fetching coin price:",o),o}}async getCoinOHLC(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"usd",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;try{var o;const c="".concat(a,"/coins/").concat(t,"/ohlc"),i={vs_currency:e,days:r},n=this.makeCacheKey(c,i),s=await this.requestWithRetry(c,{params:i,timeout:1e4},n,this.OHLC_TTL);if(Array.isArray(s)&&s.length>0)return s.map(t=>({time:t[0],open:t[1],high:t[2],low:t[3],close:t[4]}));console.warn("OHLC endpoint returned empty for ".concat(t," (days=").concat(r,"), falling back to market_chart"));const h="".concat(a,"/coins/").concat(t,"/market_chart"),l={vs_currency:e,days:r},u=this.makeCacheKey(h,l),d=await this.requestWithRetry(h,{params:l,timeout:1e4},u,this.OHLC_TTL),m=null!==(o=null===d||void 0===d?void 0:d.prices)&&void 0!==o?o:[];if(!Array.isArray(m)||0===m.length)throw new Error("No price data available from market_chart fallback");const p=r<=1?9e5:36e5,y={};for(const[t,e]of m){const r=Math.floor(t/p)*p;if(y[r]){const t=y[r];t.high=Math.max(t.high,e),t.low=Math.min(t.low,e),t.close=e}else y[r]={open:e,high:e,low:e,close:e,time:r}}const w=Object.values(y).sort((t,e)=>t.time-e.time).map(t=>({time:t.time,open:t.open,high:t.high,low:t.low,close:t.close}));if(0===w.length)throw new Error("Failed to synthesize OHLC from market_chart data");return w}catch(n){var c,i;if(console.error("Error fetching OHLC data (and fallback):",null!==(c=null===n||void 0===n?void 0:n.message)&&void 0!==c?c:n),null!==n&&void 0!==n&&n.response)throw new Error("CoinGecko API error: ".concat(n.response.status," ").concat(n.response.statusText));throw new Error(null!==(i=null===n||void 0===n?void 0:n.message)&&void 0!==i?i:"Unknown network error when fetching OHLC")}}}}}]);
//# sourceMappingURL=476.2e4458a6.chunk.js.map