{"version":3,"file":"static/js/476.2e4458a6.chunk.js","mappings":"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","sources":["services/coingeckoService.ts"],"sourcesContent":["import axios, { AxiosRequestConfig } from 'axios';\r\n\r\nconst COINGECKO_API_URL = 'https://api.coingecko.com/api/v3';\r\n\r\nexport interface CoinMarketData {\r\n  id: string;\r\n  symbol: string;\r\n  name: string;\r\n  current_price: number;\r\n  market_cap: number;\r\n  market_cap_rank: number;\r\n  price_change_24h: number;\r\n  price_change_percentage_24h: number;\r\n  high_24h: number;\r\n  low_24h: number;\r\n  total_volume: number;\r\n  image: string;\r\n}\r\n\r\nexport interface CoinOHLCData {\r\n  time: number;\r\n  open: number;\r\n  high: number;\r\n  low: number;\r\n  close: number;\r\n}\r\n\r\nexport interface DetailedCoinData {\r\n  id: string;\r\n  symbol: string;\r\n  name: string;\r\n  description: { en: string };\r\n  market_data: {\r\n    current_price: { [key: string]: number };\r\n    ath: { [key: string]: number };\r\n    ath_change_percentage: { [key: string]: number };\r\n    ath_date: { [key: string]: string };\r\n    market_cap: { [key: string]: number };\r\n    total_volume: { [key: string]: number };\r\n    high_24h: { [key: string]: number };\r\n    low_24h: { [key: string]: number };\r\n    price_change_24h: number;\r\n    price_change_percentage_24h: number;\r\n    price_change_percentage_7d: number;\r\n    price_change_percentage_30d: number;\r\n  };\r\n}\r\n\r\nclass CoinGeckoService {\r\n  // Simple in-memory cache to reduce request rate and dedupe concurrent calls\r\n  private cache = new Map<string, { expires: number; data: any; promise?: Promise<any> }>();\r\n\r\n  // Default TTLs (ms)\r\n  private MARKET_TTL = 30 * 1000; // 30s for market list\r\n  private OHLC_TTL = 25 * 1000; // 25s for OHLC (slightly less than polling interval)\r\n\r\n  // Retry settings\r\n  private MAX_RETRIES = 3;\r\n  private INITIAL_BACKOFF = 500; // ms\r\n\r\n  private async sleep(ms: number) {\r\n    return new Promise((res) => setTimeout(res, ms));\r\n  }\r\n\r\n  private makeCacheKey(url: string, params?: Record<string, any>) {\r\n    if (!params) return url;\r\n    const keys = Object.keys(params).sort();\r\n    const parts = keys.map((k) => `${k}=${JSON.stringify(params[k])}`);\r\n    return `${url}?${parts.join('&')}`;\r\n  }\r\n\r\n  private async requestWithRetry<T = any>(url: string, config: AxiosRequestConfig = {}, cacheKey?: string, ttl?: number): Promise<T> {\r\n    // Caching: return cached value if valid\r\n    if (cacheKey && ttl) {\r\n      const cached = this.cache.get(cacheKey);\r\n      const now = Date.now();\r\n      if (cached) {\r\n        if (cached.data && cached.expires > now) {\r\n          return cached.data as T;\r\n        }\r\n        if (cached.promise) {\r\n          // A request for this key is already in progress â€” wait for it\r\n          return cached.promise as Promise<T>;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Create a promise and store it to dedupe concurrent calls\r\n    const perform = async (): Promise<T> => {\r\n      let attempt = 0;\r\n      let lastErr: any = null;\r\n      while (attempt < this.MAX_RETRIES) {\r\n        try {\r\n          const res = await axios.get(url, config);\r\n          // successful\r\n          if (cacheKey && ttl) {\r\n            this.cache.set(cacheKey, { data: res.data, expires: Date.now() + (ttl || 0) });\r\n          }\r\n          return res.data as T;\r\n        } catch (err: any) {\r\n          lastErr = err;\r\n          // If rate limited (429), throw immediately with helpful message\r\n          const status = err?.response?.status;\r\n          if (status === 429) {\r\n            throw new Error('Rate limit exceeded (429) from CoinGecko. Back off and retry later.');\r\n          }\r\n\r\n          // For client errors (4xx other than 429), don't retry\r\n          if (status && status >= 400 && status < 500) {\r\n            throw new Error(`CoinGecko API error: ${status} ${err?.response?.statusText ?? ''}`);\r\n          }\r\n\r\n          // Otherwise retry with exponential backoff\r\n          attempt += 1;\r\n          const backoff = this.INITIAL_BACKOFF * Math.pow(2, attempt - 1);\r\n          await this.sleep(backoff);\r\n        }\r\n      }\r\n      // Exhausted retries\r\n      throw lastErr ?? new Error('Unknown network error');\r\n    };\r\n\r\n    const promise = perform();\r\n    if (cacheKey && ttl) {\r\n      this.cache.set(cacheKey, { expires: Date.now() + (ttl || 0), data: undefined, promise });\r\n    }\r\n    try {\r\n      const result = await promise;\r\n      // ensure cache entry has data & expires\r\n      if (cacheKey && ttl) this.cache.set(cacheKey, { expires: Date.now() + (ttl || 0), data: result });\r\n      return result;\r\n    } catch (err) {\r\n      // on failure, remove the pending cache entry so future calls can retry\r\n      if (cacheKey) this.cache.delete(cacheKey);\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Get list of supported coins with basic info\r\n  async getSupportedCoins(): Promise<{ id: string; symbol: string; name: string }[]> {\r\n    try {\r\n      const url = `${COINGECKO_API_URL}/coins/list`;\r\n      const cacheKey = this.makeCacheKey(url);\r\n      const data = await this.requestWithRetry<{ id: string; symbol: string; name: string }[]>(url, {}, cacheKey, this.MARKET_TTL);\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching supported coins:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get current market data for specified coins\r\n  async getMarketData(): Promise<CoinMarketData[]> {\r\n    try {\r\n      const url = `${COINGECKO_API_URL}/coins/markets`;\r\n      const params = { vs_currency: 'usd', order: 'market_cap_desc', per_page: 100, page: 1, sparkline: false };\r\n      const cacheKey = this.makeCacheKey(url, params);\r\n      const data = await this.requestWithRetry<CoinMarketData[]>(url, { params, timeout: 10000 }, cacheKey, this.MARKET_TTL);\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching market data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getCoinMarketData(\r\n    coinId: string,\r\n    vsCurrency: string = 'usd',\r\n    days: string = '1',\r\n    interval: string = 'hourly'\r\n  ): Promise<CoinMarketData> {\r\n    try {\r\n      const url = `${COINGECKO_API_URL}/coins/${coinId}/market_chart`;\r\n      const params = { vs_currency: vsCurrency, days, interval };\r\n      const cacheKey = this.makeCacheKey(url, params);\r\n      const data = await this.requestWithRetry<any>(url, { params, timeout: 15000 }, cacheKey, this.OHLC_TTL);\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching market data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getCoinList(): Promise<Array<{ id: string; symbol: string; name: string }>> {\r\n    try {\r\n      const url = `${COINGECKO_API_URL}/coins/list`;\r\n      const cacheKey = this.makeCacheKey(url);\r\n      const data = await this.requestWithRetry<{ id: string; symbol: string; name: string }[]>(url, {}, cacheKey, this.MARKET_TTL);\r\n      return data;\r\n    } catch (error) {\r\n      console.error('Error fetching coin list:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getCoinPrice(\r\n    coinId: string,\r\n    vsCurrency: string = 'usd'\r\n  ): Promise<number> {\r\n    try {\r\n      const url = `${COINGECKO_API_URL}/simple/price`;\r\n      const params = { ids: coinId, vs_currencies: vsCurrency };\r\n      const cacheKey = this.makeCacheKey(url, params);\r\n      const data = await this.requestWithRetry<any>(url, { params, timeout: 8000 }, cacheKey, 5000);\r\n      return data?.[coinId]?.[vsCurrency];\r\n    } catch (error) {\r\n      console.error('Error fetching coin price:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getCoinOHLC(\r\n    coinId: string,\r\n    vsCurrency: string = 'usd',\r\n    days: number = 1\r\n  ): Promise<CoinOHLCData[]> {\r\n    try {\r\n      const url = `${COINGECKO_API_URL}/coins/${coinId}/ohlc`;\r\n      const params = { vs_currency: vsCurrency, days };\r\n      const cacheKey = this.makeCacheKey(url, params);\r\n\r\n      const responseData = await this.requestWithRetry<any[]>(url, { params, timeout: 10000 }, cacheKey, this.OHLC_TTL);\r\n\r\n      // OHLC endpoint returns an array of [time, open, high, low, close]\r\n      if (Array.isArray(responseData) && responseData.length > 0) {\r\n        return responseData.map((item: [number, number, number, number, number]) => ({\r\n          time: item[0],\r\n          open: item[1],\r\n          high: item[2],\r\n          low: item[3],\r\n          close: item[4]\r\n        }));\r\n      }\r\n\r\n      // If OHLC returned empty, fallback to market_chart and synthesize OHLC\r\n      console.warn(`OHLC endpoint returned empty for ${coinId} (days=${days}), falling back to market_chart`);\r\n\r\n      const mcUrl = `${COINGECKO_API_URL}/coins/${coinId}/market_chart`;\r\n      const mcParams = { vs_currency: vsCurrency, days };\r\n      const mcCacheKey = this.makeCacheKey(mcUrl, mcParams);\r\n      const mc = await this.requestWithRetry<any>(mcUrl, { params: mcParams, timeout: 10000 }, mcCacheKey, this.OHLC_TTL);\r\n\r\n      // market_chart returns prices: [ [timestamp, price], ... ]\r\n      const prices: [number, number][] = mc?.prices ?? [];\r\n      if (!Array.isArray(prices) || prices.length === 0) {\r\n        throw new Error('No price data available from market_chart fallback');\r\n      }\r\n\r\n      // Aggregate prices into OHLC candles. We'll create one candle per intervalMs.\r\n      const intervalMs = days <= 1 ? 15 * 60 * 1000 : 60 * 60 * 1000; // 15min for intraday, else hourly\r\n\r\n      const buckets: Record<number, { open: number; high: number; low: number; close: number; time: number } > = {};\r\n      for (const [ts, price] of prices) {\r\n        const time = Math.floor(ts / intervalMs) * intervalMs;\r\n        if (!buckets[time]) {\r\n          buckets[time] = { open: price, high: price, low: price, close: price, time };\r\n        } else {\r\n          const b = buckets[time];\r\n          b.high = Math.max(b.high, price);\r\n          b.low = Math.min(b.low, price);\r\n          b.close = price;\r\n        }\r\n      }\r\n\r\n      const result = Object.values(buckets)\r\n        .sort((a, b) => a.time - b.time)\r\n        .map(b => ({ time: b.time, open: b.open, high: b.high, low: b.low, close: b.close }));\r\n\r\n      if (result.length === 0) throw new Error('Failed to synthesize OHLC from market_chart data');\r\n      return result;\r\n    } catch (error: any) {\r\n      console.error('Error fetching OHLC data (and fallback):', error?.message ?? error);\r\n      // Normalize axios/network errors into a clear Error\r\n      if (error?.response) {\r\n        throw new Error(`CoinGecko API error: ${error.response.status} ${error.response.statusText}`);\r\n      }\r\n      throw new Error(error?.message ?? 'Unknown network error when fetching OHLC');\r\n    }\r\n  }\r\n}\r\n\r\n// Export a singleton instance\r\nexport const coinGeckoService = new CoinGeckoService();"],"names":["COINGECKO_API_URL","coinGeckoService","constructor","cache","Map","MARKET_TTL","OHLC_TTL","MAX_RETRIES","INITIAL_BACKOFF","sleep","ms","Promise","res","setTimeout","makeCacheKey","url","params","parts","Object","keys","sort","map","k","concat","JSON","stringify","join","requestWithRetry","config","arguments","length","undefined","cacheKey","ttl","cached","this","get","now","Date","data","expires","promise","async","_lastErr","attempt","lastErr","axios","set","err","_err$response","status","response","Error","_err$response$statusT","_err$response2","statusText","backoff","Math","pow","perform","result","delete","getSupportedCoins","error","console","getMarketData","vs_currency","order","per_page","page","sparkline","timeout","getCoinMarketData","coinId","vsCurrency","days","interval","getCoinList","getCoinPrice","_data$coinId","ids","vs_currencies","getCoinOHLC","_mc$prices","responseData","Array","isArray","item","time","open","high","low","close","warn","mcUrl","mcParams","mcCacheKey","mc","prices","intervalMs","buckets","ts","price","floor","b","max","min","values","a","_error$message","_error$message2","message"],"sourceRoot":""}